# 設計與架構文件

本文件闡述了 Skin Retoucher Pro 應用程式在開發過程中採用的技術架構、核心演算法以及設計決策。

## 1. 核心概念：高低頻分離 (Frequency Separation)

本專案使用的基礎技術是**高低頻分離**。此方法將影像分解為兩個獨立的圖層：

1.  **低頻圖層 (顏色/色調)**：此圖層包含影像中大面積的顏色與色調資訊。我們透過對原始影像應用**高斯模糊 (Gaussian Blur)** 來生成此圖層。UI 介面中的「平滑度」滑桿直接控制此次模糊的標準差 (sigma)。

2.  **高頻圖層 (紋理/細節)**：此圖層包含精細的細節與紋理，例如毛孔、毛髮和細紋。它的計算方式是原始影像與低頻（模糊後）圖層之間的差值：
    `高頻圖層 = 原始影像 - 低頻圖層`

透過獨立操作這些圖層（例如，平滑化低頻圖層），然後再將它們重新組合，我們可以在不破壞自然皮膚紋理的前提下，實現高品質的皮膚修飾效果。

## 2. 應用程式架構

本應用程式採用標準的 Electron 架構，將 Node.js 後端 (主程序) 與基於瀏覽器的前端 (渲染程序) 分離開來。

-   **主程序 (`main.js`)**:
    -   負責建立與管理應用程式視窗 (`BrowserWindow`)。
    -   處理原生的作業系統互動，例如開啟「儲存檔案」或「選擇資料夾」對話框。
    -   透過行程間通訊 (IPC) 監聽來自渲染程序的事件，並執行檔案的讀取與儲存。

-   **渲染程序 (`renderer.js`, `index.html`)**:
    -   管理整個使用者介面與使用者互動。
    -   持有用於所有 WebGL 渲染的 `<canvas>` 元素。
    -   包含所有在 WebGL 與 GLSL 中實現的核心影像處理邏輯。

-   **預載入腳本 (`preload.js`)**:
    -   作為主程序與渲染程序之間的一個安全橋樑。
    -   使用 `contextBridge` 向渲染程序暴露一個安全的、受限的 API (例如 `window.electronAPI.saveImage`)，從而避免了在前端啟用完整 Node.js 整合所帶來的安全風險。

## 3. WebGL 即時渲染管線

應用程式的核心是一個多通道 (multi-pass) 渲染管線，它利用**幀緩衝區物件 (Framebuffer Objects, FBOs)** 在離屏環境中執行計算，並將最終結果渲染到畫布上供使用者即時預覽。

**管線經過優化，分離了原始遮罩與模糊遮罩的處理：**

#### Pass 1: 皮膚遮罩生成 (硬邊)
-   **輸入**: 原始影像紋理、使用者選擇的膚色 (作為一個 HSV 值的 `uniform` 陣列)，以及「顏色容差」值。
-   **輸出**: 一張黑白兩色的硬邊皮膚遮罩紋理，被渲染到一個**專用的 FBO (`fbo[4]`)** 中，此結果**僅供預覽視窗使用**。

#### Pass 2 & 3: 低頻圖層生成 (兩通道高斯模糊)
-   **流程**: 採用可分離的高斯模糊，先進行水平模糊，再對其結果進行垂直模糊。
-   **輸出**: 最終完全模糊的低頻圖層紋理，被渲染到一個 FBO (`fbo[1]`) 中。

#### Pass 4 & 5: 皮膚遮罩模糊化
-   **輸入**: Pass 1 中生成的**硬邊遮罩 (`textures[4]`)**。
-   **流程**: 對硬邊遮罩採用兩通道高斯模糊處理，以柔化其邊緣。
-   **輸出**: 一張邊緣柔和的灰階遮罩紋理，被渲染到另一個 FBO (`fbo[3]`) 中，此結果**供最終合成使用**。

#### Pass 6: 最終合成
-   **流程**: 這是主要的合成階段，著色器會組合原始紋理、低頻圖層紋理 (`textures[1]`) 和**模糊後的皮膚遮罩 (`textures[3]`)**。它會根據「遮罩擴張」值對遮罩進行 `smoothstep` 處理，並根據「細節保留」和「除錯檢視」模式計算出最終效果。
-   **輸出**: 最終影像被渲染到使用者可見的主畫布上。

#### Pass 7: 遮罩預覽渲染
-   **流程**: 在主畫布渲染完成後，程式會啟用 `gl.scissor` 來限定一個小範圍的繪圖區域。然後，它會將 Pass 1 生成的**未經模糊的硬邊遮罩 (`textures[4]`)** 直接渲染到這個區域。
-   **輸出**: 一個清晰、無模糊、無背景的遮罩預覽，疊加在主畫布的右上角。

## 4. 互動與視窗管理

為了解決 UI 互動中的佈局錯誤和效能瓶頸，我們採用了更穩健的策略。

### 視窗縮放 (Window Resizing)
-   **問題**: 之前在縮放視窗時，由於 JavaScript 過早介入尺寸計算，會導致 Flexbox 佈局崩潰，使右側欄消失。
-   **解決方案**:
    1.  **CSS 驅動佈局**: 我們為 `<canvas>` 元素新增了 `width: 100%` 和 `height: 100%` 樣式，將佈局的權威完全交給 CSS 的 Flexbox 模型。
    2.  **JavaScript 同步尺寸**: JavaScript 的職責被重新定義為**觀察者**。它會監聽 `resize` 事件，讀取由 CSS 決定的 `<canvas>` 實際顯示尺寸 (`clientWidth`, `clientHeight`)，然後同步更新 WebGL 的繪圖緩衝區尺寸 (`canvas.width`, `canvas.height`) 和視口 (`gl.viewport`)。
    3.  **節流 (Throttle)**: 為了在連續縮放時保持流暢的互動，`resize` 事件的處理函式被一個 `throttle` 函式包裹，確保重繪操作每 100 毫秒最多執行一次，既保證了即時性，又避免了效能問題。

### 滾輪縮放 (Wheel Zooming)
-   **問題**: 原始的縮放邏輯未正確計算縮放中心，導致畫面總是偏向右下角。
-   **解決方案**: `handleWheel` 函式被完全重寫，採用了更精確的座標轉換演算法：
    1.  將滑鼠在畫布上的螢幕座標，透過逆變換矩陣，精確計算出其在當前平移/縮放狀態下所對應的**圖片內部座標**。
    2.  計算新的縮放比例。
    3.  基於新的縮放比例，反向計算出一個新的平移量 (`panX`, `panY`)，其目標是確保第一步中計算出的那個**圖片內部座標**，在縮放後依然位於滑鼠指標的正下方。這確保了縮放始終圍繞視覺中心進行。

### 預覽視窗拖曳 (Preview Dragging)
-   **問題**: 拖動預覽視窗時，由於 WebGL 未被通知重繪，導致遮罩內容殘留在原地。
-   **解決方案**: 在負責拖曳的 `initDraggable` 函式的 `mousemove` 事件監聽器中，在更新完視窗的 CSS 位置後，立即呼叫一次 `render()` 函式。這確保了 WebGL 的裁剪區域 (`gl.scissor`) 與 CSS 視窗的位置時時刻刻保持同步。

## 5. 批次處理模組

為了在不干擾即時渲染管線的前提下，安全地實現批次處理功能，我們採用了**狀態隔離**的原則。

-   **獨立模組 (`BatchProcessor`)**:
    -   在 `renderer.js` 中，我們建立了一個名為 `BatchProcessor` 的獨立物件模組。
    -   此模組**封裝**了所有與批次處理相關的狀態（`queue`, `currentIndex`, `isProcessing`）和方法 (`start`, `processNext`, `stop` 等)。

-   **無副作用的離屏渲染 (`renderImageOffscreen`)**:
    -   這是 `BatchProcessor` 的核心函式，也是實現狀態隔離的關鍵。
    -   此函式接收一個圖片物件作為輸入，返回 Base64 格式的 PNG 資料作為輸出。
    -   **關鍵設計**：為了避免污染主畫布的 WebGL 狀態，此函式在執行時，會**自行創建**所有它需要的臨時 WebGL 資源（包括 FBOs、Textures 和 Buffers），並在執行完畢後，**立即將它們全部銷毀**。
    -   這確保了無論批次處理在做什麼，都不會對使用者正在觀看的即時預覽 (`render()` 函式) 產生任何副作用。

-   **程式碼重用**:
    -   單張圖片的「儲存」功能 (`handleSave`) 現在也直接呼叫 `BatchProcessor.renderImageOffscreen` 函式，確保了兩種儲存模式使用完全相同的、穩定可靠的渲染核心。
