# 設計與架構文件

本文件闡述了 Skin Retoucher Pro 應用程式在開發過程中採用的技術架構、核心演算法以及設計決策。

## 1. 核心概念：高低頻分離 (Frequency Separation)

本專案使用的基礎技術是**高低頻分離**。此方法將影像分解為兩個獨立的圖層：

1.  **低頻圖層 (顏色/色調)**：此圖層包含影像中大面積的顏色與色調資訊。我們透過對原始影像應用**高斯模糊 (Gaussian Blur)** 來生成此圖層。UI 介面中的 `Smoothness` (平滑度) 滑桿直接控制此次模糊的標準差 (sigma)。

2.  **高頻圖層 (紋理/細節)**：此圖層包含精細的細節與紋理，例如毛孔、毛髮和細紋。它的計算方式是原始影像與低頻（模糊後）圖層之間的差值：
    `高頻圖層 = 原始影像 - 低頻圖層`

透過獨立操作這些圖層（例如，平滑化低頻圖層），然後再將它們重新組合，我們可以在不破壞自然皮膚紋理的前提下，實現高品質的皮膚修飾效果。

## 2. 應用程式架構

本應用程式採用標準的 Electron 架構，將 Node.js 後端 (主程序) 與基於瀏覽器的前端 (渲染程序) 分離開來。

-   **主程序 (`main.js`)**:
    -   負責建立與管理應用程式視窗 (`BrowserWindow`)。
    -   處理原生的作業系統互動，例如開啟「儲存檔案」對話框。
    -   透過行程間通訊 (IPC) 監聽來自渲染程序的事件。

-   **渲染程序 (`renderer.js`, `index.html`)**:
    -   管理整個使用者介面與使用者互動。
    -   持有用於所有 WebGL 渲染的 `<canvas>` 元素。
    -   包含所有在 WebGL 與 GLSL 中實現的核心影像處理邏輯。

-   **預載入腳本 (`preload.js`)**:
    -   作為主程序與渲染程序之間的一個安全橋樑。
    -   使用 `contextBridge` 向渲染程序暴露一個安全的、受限的 API (例如 `window.electronAPI.saveImage`)，從而避免了在前端啟用完整 Node.js 整合所帶來的安全風險。

## 3. WebGL 渲染管線

應用程式的核心是一個多通道 (multi-pass) 渲染管線，它利用**幀緩衝區物件 (Framebuffer Objects, FBOs)** 在離屏環境中執行計算。所有處理都在原始影像的解析度下進行，以確保品質。

管線按以下順序執行：

#### Pass 1: 皮膚遮罩生成
-   **輸入**: 原始影像紋理、使用者選擇的膚色 (作為一個 HSV 值的 `uniform` 陣列)，以及 `tolerance` (容差) 值。當使用者右鍵點擊選取第 11 個顏色時，系統會自動丟棄先前 10 個顏色中最舊的一個，以確保陣列中始終保留最新的 10 個選取色。
-   **著色器**: `maskFragmentShader.glsl`
-   **處理流程**: 對於輸入影像的每個像素，著色器會：
    1.  將像素的顏色從 RGB 轉換為 HSV 色彩空間。
    2.  計算該像素與每個被選膚色在色相 (Hue) 和飽和度 (Saturation) 上的差異。
    3.  如果差異在任何一個被選膚色的 `tolerance` 閾值之內，該像素的輸出即為 `1.0` (白色)；否則為 `0.0` (黑色)。
-   **輸出**: 一張黑白兩色的皮膚遮罩紋理，被渲染到一個 FBO 中。

#### Pass 2 & 3: 低頻圖層生成 (兩通道高斯模糊)
為了高效地生成模糊後 (低頻) 的圖層，我們採用了可分離的高斯模糊，這比單一的大型 2D 核心運算要快得多。
-   **Pass 2 (水平模糊)**:
    -   **輸入**: 原始影像紋理。
    -   **著色器**: `blurFragmentShader.glsl` (其中 `u_dir` 設為 `(1.0, 0.0)`)。
    -   **輸出**: 一張水平模糊後的紋理，被渲染到一個 FBO 中。
-   **Pass 3 (垂直模糊)**:
    -   **輸入**: 來自 Pass 2 的水平模糊紋理。
    -   **著色器**: `blurFragmentShader.glsl` (其中 `u_dir` 設為 `(0.0, 1.0)`)。
    -   **輸出**: 最終完全模糊的低頻圖層紋理，被渲染到另一個 FBO 中。

#### Pass 4: 最終合成與顯示
這是最後的階段，所有先前生成的圖層將被組合起來並顯示在螢幕上。
-   **輸入**: 原始紋理、低頻圖層紋理、皮膚遮罩紋理，以及來自 UI 的參數 (`detailAmount`, `viewMode`)。
-   **著色器**: `finalFragmentShader.glsl`
-   **處理流程**:
    1.  即時計算高頻圖層：`highPass = original - lowFrequency`。
    2.  計算平滑後的皮膚顏色：`smoothedSkin = lowFrequency + highPass * detailAmount`。
    3.  使用遮罩將原始影像與平滑後的皮膚進行混合：`finalColor = mix(original, smoothedSkin, mask)`。這確保了平滑效果只應用於皮膚遮罩所定義的區域。
    4.  著色器中也包含了切換至**除錯預覽 (Debug Views)** 的邏輯，可根據請求僅輸出遮罩、高頻或低頻圖層。
-   **輸出**: 最終影像被渲染到使用者可見的主畫布上。在此階段，`u_transform` 矩陣會在頂點著色器中被應用，以處理使用者的平移和縮放操作。

## 4. 視口與座標系統

-   **長寬比校正**: 應用程式的畫布尺寸始終與其容器的尺寸相匹配。為防止影像變形，程式會計算一個變換矩陣 (`u_transform`)。此矩陣會應用一個長寬比校正因子，有效地在影像周圍添加黑邊 (letterboxing 或 pillarboxing)，使其始終以原始的長寬比顯示。
-   **平移與縮放**: 使用者的互動 (滑鼠拖曳、滾輪) 會更新 `scale`、`panX` 和 `panY` 狀態變數。這些變數隨後被用來建構 `u_transform` 矩陣，並在最終的合成通道中傳遞給頂點著色器。
-   **顏色拾取座標轉換**: 為了確保在任何縮放或平移級別下都能準確拾取顏色，來自右鍵點擊事件的螢幕座標必須被轉換回原始影像的紋理座標。這是透過計算並應用 `u_transform` 矩陣的**逆矩陣**到滑鼠的裁剪空間 (clip-space) 座標上來實現的。這個穩健的方法能將螢幕上的位置精確地映射回來源影像上的正確像素。