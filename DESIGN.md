# 設計與架構文件

本文件闡述了 Skin Retoucher Pro 應用程式在開發過程中採用的技術架構、核心演算法以及設計決策。

## 1. 核心概念：高低頻分離 (Frequency Separation)

本專案使用的基礎技術是**高低頻分離**。此方法將影像分解為兩個獨立的圖層：

1.  **低頻圖層 (顏色/色調)**：此圖層包含影像中大面積的顏色與色調資訊。我們透過對原始影像應用**高斯模糊 (Gaussian Blur)** 來生成此圖層。UI 介面中的 `Smoothness` (平滑度) 滑桿直接控制此次模糊的標準差 (sigma)。

2.  **高頻圖層 (紋理/細節)**：此圖層包含精細的細節與紋理，例如毛孔、毛髮和細紋。它的計算方式是原始影像與低頻（模糊後）圖層之間的差值：
    `高頻圖層 = 原始影像 - 低頻圖層`

透過獨立操作這些圖層（例如，平滑化低頻圖層），然後再將它們重新組合，我們可以在不破壞自然皮膚紋理的前提下，實現高品質的皮膚修飾效果。

## 2. 應用程式架構

本應用程式採用標準的 Electron 架構，將 Node.js 後端 (主程序) 與基於瀏覽器的前端 (渲染程序) 分離開來。

-   **主程序 (`main.js`)**:
    -   負責建立與管理應用程式視窗 (`BrowserWindow`)。
    -   處理原生的作業系統互動，例如開啟「儲存檔案」或「選擇資料夾」對話框。
    -   透過行程間通訊 (IPC) 監聽來自渲染程序的事件，並執行檔案的讀取與儲存。

-   **渲染程序 (`renderer.js`, `index.html`)**:
    -   管理整個使用者介面與使用者互動。
    -   持有用於所有 WebGL 渲染的 `<canvas>` 元素。
    -   包含所有在 WebGL 與 GLSL 中實現的核心影像處理邏輯。

-   **預載入腳本 (`preload.js`)**:
    -   作為主程序與渲染程序之間的一個安全橋樑。
    -   使用 `contextBridge` 向渲染程序暴露一個安全的、受限的 API (例如 `window.electronAPI.saveImage`, `window.electronAPI.openFolderDialog`)，從而避免了在前端啟用完整 Node.js 整合所帶來的安全風險。

## 3. WebGL 即時渲染管線

應用程式的核心是一個多通道 (multi-pass) 渲染管線，它利用**幀緩衝區物件 (Framebuffer Objects, FBOs)** 在離屏環境中執行計算，並將最終結果渲染到畫布上供使用者即時預覽。

管線按以下順序執行：

#### Pass 1: 皮膚遮罩生成
-   **輸入**: 原始影像紋理、使用者選擇的膚色 (作為一個 HSV 值的 `uniform` 陣列)，以及 `tolerance` (容差) 值。當使用者右鍵點擊選取第 11 個顏色時，系統會自動丟棄先前 10 個顏色中最舊的一個，以確保陣列中始終保留最新的 10 個選取色。
-   **輸出**: 一張黑白兩色的皮膚遮罩紋理，被渲染到一個 FBO (`framebuffers[2]`) 中。

#### Pass 2 & 3: 低頻圖層生成 (兩通道高斯模糊)
-   **流程**: 採用可分離的高斯模糊，先進行水平模糊 (輸出到 `framebuffers[0]`)，再對水平模糊的結果進行垂直模糊。
-   **輸出**: 最終完全模糊的低頻圖層紋理，被渲染到另一個 FBO (`framebuffers[1]`) 中。

#### Pass 4: 最終合成與顯示
-   **流程**: 這是最後的階段，著色器會組合原始紋理、低頻圖層紋理和皮膚遮罩紋理，並根據 UI 參數 (`detailAmount`, `viewMode`) 計算出最終效果。
-   **輸出**: 最終影像被渲染到使用者可見的主畫布上。在此階段，`u_transform` 矩陣會被應用，以處理使用者的平移和縮放操作。

## 4. 批次處理模組

為了在不干擾即時渲染管線的前提下，安全地實現批次處理功能，我們採用了**模組化元件模式 (MCP)**，並嚴格遵守**狀態隔離**原則。

-   **獨立模組 (`BatchProcessor`)**:
    -   在 `renderer.js` 中，我們建立了一個名為 `BatchProcessor` 的獨立物件模組。
    -   此模組**封裝**了所有與批次處理相關的狀態（`queue`, `currentIndex`, `isProcessing`）和方法 (`start`, `processNext`, `stop` 等)。

-   **無副作用的離屏渲染 (`renderImageOffscreen`)**:
    -   這是 `BatchProcessor` 的核心函式，也是實現狀態隔離的關鍵。
    -   此函式接收一個圖片物件作為輸入，返回 Base64 格式的 PNG 資料作為輸出。
    -   **關鍵設計**：為了避免污染主畫布的 WebGL 狀態，此函式在執行時，會**自行創建**所有它需要的臨時 WebGL 資源（包括 FBOs 和 Textures），並在執行完畢後，**立即將它們全部銷毀**。
    -   這確保了無論批次處理在做什麼，都不會對使用者正在觀看的即時預覽 (`render()` 函式) 產生任何副作用。

-   **工作流程**:
    1.  使用者點擊「Batch Process」按鈕，觸發 `BatchProcessor.handleBatchClick`。
    2.  `BatchProcessor` 透過 IPC 請求主程序開啟資料夾選擇視窗。
    3.  主程序返回圖片檔案列表，觸發 `BatchProcessor.start`，開始處理流程。
    4.  `processNext` 方法被依序呼叫，每次處理一張圖片。
    5.  在 `processNext` 中，`renderImageOffscreen` 被呼叫以生成處理後的圖片資料。
    6.  處理後的資料透過 IPC 傳送給主程序儲存。
    7.  收到主程序儲存成功的回應後，繼續處理下一張，直到佇列完成。

-   **程式碼重用**:
    -   單張圖片的「儲存」功能 (`handleSave`) 現在也直接呼叫 `BatchProcessor.renderImageOffscreen` 函式，確保了兩種儲存模式使用完全相同的、穩定可靠的渲染核心。

## 5. 視口與座標系統

-   **長寬比校正**: 應用程式的畫布尺寸始終與其容器的尺寸相匹配。為防止影像變形，程式會計算一個變換矩陣 (`u_transform`)。此矩陣會應用一個長寬比校正因子，有效地在影像周圍添加黑邊 (letterboxing 或 pillarboxing)，使其始終以原始的長寬比顯示。
-   **平移與縮放**: 使用者的互動 (滑鼠拖曳、滾輪) 會更新 `scale`、`panX` 和 `panY` 狀態變數。這些變數隨後被用來建構 `u_transform` 矩陣，並在最終的合成通道中傳遞給頂點著色器。
-   **顏色拾取座標轉換**: 為了確保在任何縮放或平移級別下都能準確拾取顏色，來自右鍵點擊事件的螢幕座標必須被轉換回原始影像的紋理座標。這是透過計算並應用 `u_transform` 矩陣的**逆矩陣**到滑鼠的裁剪空間 (clip-space) 座標上來實現的。這個穩健的方法能將螢幕上的位置精確地映射回來源影像上的正確像素。
