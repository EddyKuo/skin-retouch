# 設計與架構文件

本文件闡述了 Skin Retoucher Pro 應用程式在開發過程中採用的技術架構、核心演算法以及設計決策。

## 1. 核心概念：高低頻分離 (Frequency Separation)

本專案使用的基礎技術是**高低頻分離**。此方法將影像分解為兩個獨立的圖層：

1.  **低頻圖層 (顏色/色調)**：此圖層包含影像中大面積的顏色與色調資訊。我們透過對原始影像應用**高斯模糊 (Gaussian Blur)** 來生成此圖層。UI 介面中的 `Smoothness` (平滑度) 滑桿直接控制此次模糊的標準差 (sigma)。

2.  **高頻圖層 (紋理/細節)**：此圖層包含精細的細節與紋理，例如毛孔、毛髮和細紋。它的計算方式是原始影像與低頻（模糊後）圖層之間的差值：
    `高頻圖層 = 原始影像 - 低頻圖層`

透過獨立操作這些圖層（例如，平滑化低頻圖層），然後再將它們重新組合，我們可以在不破壞自然皮膚紋理的前提下，實現高品質的皮膚修飾效果。

## 2. 應用程式架構

本應用程式採用標準的 Electron 架構，並在渲染程序中實現了高度的**模組化**，以提高程式碼的可維護性和清晰度。

-   **主程序 (`main.js`)**:
    -   負責建立與管理應用程式視窗 (`BrowserWindow`)。
    -   處理原生的作業系統互動，例如開啟「儲存檔案」或「選擇資料夾」對話框。
    -   透過行程間通訊 (IPC) 監聽來自渲染程序的事件，並執行檔案的讀取與儲存。

-   **預載入腳本 (`preload.js`)**:
    -   作為主程序與渲染程序之間的一個安全橋樑。
    -   使用 `contextBridge` 向渲染程序暴露一個安全的、受限的 API (例如 `window.electronAPI.saveImage`)，避免了安全風險。

-   **渲染程序 (模組化)**:
    -   **`renderer.js`**: 作為**主入口**，負責初始化所有模組、建立集中的 `appState` 物件來管理應用程式狀態，並協調各模組之間的運作。
    -   **`webgl-renderer.js`**: 封裝了所有核心的 WebGL 邏輯。它以一個 `WebGLRenderer` 類別的形式存在，管理著 WebGL 上下文、著色器程序、緩衝區和幀緩衝區。它提供了 `setup` 和 `render` 等高階 API 給主程序呼叫。
    -   **`ui-handlers.js`**: 包含所有與 UI 互動直接相關的事件處理函式 (例如 `handleFileSelect`, `handleSliderChange`)。它監聽 DOM 事件，並根據使用者操作更新 `appState`，然後呼叫 `WebGLRenderer` 進行重新渲染。
    -   **`viewport-controls.js`**: 專門處理畫布的縮放 (wheel) 和平移 (mouse drag) 事件，並在視口變化時觸發重新渲染。
    -   **`batch-processor.js`**: 以 `BatchProcessor` 類別的形式，獨立管理所有批次處理的狀態和邏輯，確保其與即時渲染管線的狀態隔離。
    -   **`shaders.js`**: 集中存放所有 GLSL 著色器原始碼字串，便於管理和修改。
    -   **`utils.js`**: 包含可重用的輔助函式，例如顏色空間轉換 (`rgbToHsv`)。

## 3. WebGL 即時渲染管線

應用程式的核心是一個多通道 (multi-pass) 渲染管線，它利用**幀緩衝區物件 (Framebuffer Objects, FBOs)** 在離屏環境中執行計算，並將最終結果渲染到畫布上供使用者即時預覽。

管線按以下順序執行：

#### Pass 1: 皮膚遮罩生成 (硬邊)
-   **輸入**: 原始影像紋理、使用者選擇的膚色 (HSV `uniform` 陣列)，以及 `tolerance` (容差) 值。
-   **輸出**: 一張黑白兩色的硬邊皮膚遮罩紋理，被渲染到一個臨時 FBO 中。

#### Pass 2 & 3: 低頻圖層生成 (兩通道高斯模糊)
-   **流程**: 採用可分離的高斯模糊，先進行水平模糊，再對其結果進行垂直模糊。
-   **輸出**: 最終完全模糊的低頻圖層紋理，被渲染到一個 FBO 中。

#### Pass 4 & 5: 皮膚遮罩模糊化
-   **流程**: 對 Pass 1 生成的硬邊遮罩，同樣採用兩通道高斯模糊處理。
-   **輸出**: 一張邊緣柔和的灰階遮罩紋理，被渲染到另一個 FBO 中。

#### Pass 6: 最終合成與顯示
-   **流程**: 這是最後的階段，著色器會組合原始紋理、低頻圖層紋理和**模糊後的皮膚遮罩**，並根據 UI 參數 (`detailAmount`, `viewMode`) 計算出最終效果。
-   **輸出**: 最終影像被渲染到使用者可見的主畫布上。在此階段，`u_transform` 矩陣會被應用，以處理使用者的平移和縮放操作。

## 4. 批次處理模組

為了在不干擾即時渲染管線的前提下，安全地實現批次處理功能，我們將其封裝在一個獨立的 `BatchProcessor` 類別中。

-   **獨立類別 (`BatchProcessor`)**:
    -   在 `batch-processor.js` 中定義，它封裝了所有與批次處理相關的狀態（`queue`, `currentIndex`, `isProcessing`）和方法 (`start`, `processNext`, `stop` 等)。
    -   在主 `renderer.js` 中被實例化，並傳入 `appState` 和 `gl` 上下文作為依賴。

-   **無副作用的離屏渲染 (`renderImageOffscreen`)**:
    -   這是 `BatchProcessor` 的核心方法，也是實現狀態隔離的關鍵。
    -   此方法接收一個圖片物件作為輸入，返回 Base64 格式的 PNG 資料作為輸出。
    -   **關鍵設計**：為了避免污染主畫布的 WebGL 狀態，此方法在執行時，會**自行創建**所有它需要的臨時 WebGL 資源（包括 FBOs 和 Textures），並在執行完畢後，**立即將它們全部銷毀**。
    -   這確保了無論批次處理在做什麼，都不會對使用者正在觀看的即時預覽產生任何副作用。

-   **工作流程**:
    1.  使用者點擊「Batch Process」按鈕，觸發 `BatchProcessor` 實例的 `handleBatchClick` 方法。
    2.  `BatchProcessor` 透過 IPC 請求主程序開啟資料夾選擇視窗。
    3.  主程序返回圖片檔案列表，觸發 `BatchProcessor.start`，開始處理流程。
    4.  `processNext` 方法被依序呼叫，每次處理一張圖片。
    5.  在 `processNext` 中，`renderImageOffscreen` 被呼叫以生成處理後的圖片資料。
    6.  處理後的資料透過 IPC 傳送給主程序儲存。
    7.  收到主程序儲存成功的回應後，繼續處理下一張，直到佇列完成。

-   **程式碼重用**:
    -   單張圖片的「儲存」功能 (`handleSave`) 現在也直接呼叫 `BatchProcessor` 實例的 `renderImageOffscreen` 方法，確保了兩種儲存模式使用完全相同的、穩定可靠的渲染核心。

## 5. 視口與座標系統

-   **長寬比校正**: 應用程式的畫布尺寸始終與其容器的尺寸相匹配。為防止影像變形，程式會計算一個變換矩陣 (`u_transform`)。此矩陣會應用一個長寬比校正因子，有效地在影像周圍添加黑邊 (letterboxing 或 pillarboxing)，使其始終以原始的長寬比顯示。
-   **平移與縮放**: 使用者的互動 (滑鼠拖曳、滾輪) 會更新 `appState` 中的 `scale`、`panX` 和 `panY` 狀態變數。這些變數隨後被用來建構 `u_transform` 矩陣，並在最終的合成通道中傳遞給頂點著色器。
-   **顏色拾取座標轉換**: 為了確保在任何縮放或平移級別下都能準確拾取顏色，來自右鍵點擊事件的螢幕座標必須被轉換回原始影像的紋理座標。這是透過計算並應用 `u_transform` 矩陣的**逆矩陣**到滑鼠的裁剪空間 (clip-space) 座標上來實現的。這個穩健的方法能將螢幕上的位置精確地映射回來源影像上的正確像素。
