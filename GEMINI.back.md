# memory
** 在專案內使用python venv環境 **
** 請在venv內使用pip install **
** 請在venv內執行程式 **


# **Python 膚質修飾專案開發指南 (高低頻分離法)**

本指南將引導您使用 Python 開發一個專業級的皮膚修飾應用程式。專案核心採用業界標準的**高低頻分離 (Frequency Separation)** 演算法，並整合 **GPU 加速**，以實現對參數的即時調整與預覽，打造流暢的使用者體驗。

## **核心概念：高低頻分離**

高低頻分離是一種影像處理技術，其核心思想是將影像的**紋理細節**與**顏色光影**分開處理。

* **高頻層 (High Frequency Layer):** 包含影像的細節，如毛孔、頭髮、皮膚紋理、痘痘、疤痕等。  
* **低頻層 (Low Frequency Layer):** 包含影像的顏色、膚色過渡、光影等大面積的色塊資訊。

透過分離這兩層，我們可以在不破壞皮膚真實紋理（高頻層）的前提下，去平滑膚色、柔化光影（低頻層），從而達到既自然又完美的修飾效果。

## **必要的開發工具**

| 分類 | 工具 / 套件 | 用途說明 |
| :---- | :---- | :---- |
| **核心語言** | Python 3.10+ | 專案的基礎開發語言。建議使用較新版本以獲得更好的性能和語法特性。 |
| **數值計算** | NumPy | **專案的數學核心**。影像在記憶體中就是一個 n 維陣列，NumPy 提供高效的陣列操作，是執行像素級運算（如圖層加減）的基礎，無可替代。 |
| **影像讀寫** | Pillow | **負責檔案 I/O**。這是 Python 影像處理的事實標準，用於讀取使用者選擇的圖片檔案（JPG, PNG 等）和儲存處理後的結果。 |
| **圖形介面 (GUI)** | PySide6 | **打造使用者介面**。Qt 官方支援的 Python 函式庫，功能強大、專業且跨平台。我們將用它來建立視窗、滑桿、按鈕以及最重要的 **OpenGL 畫布**。 |
| **GPU 加速** | ModernGL | **實現即時性能的關鍵**。這個 Pythonic 的 OpenGL 封裝庫能讓我們將高斯模糊、圖層混合等密集型計算任務交給 GPU，實現拖動滑桿時的**即時預覽**。 |
| **GPU 程式語言** | GLSL | **在 GPU 上執行的演算法**。這不是 Python 套件，而是您需要另外編寫的著色器語言。所有像素級的運算，如高斯模糊、圖層加減等，都將在這裡實作。 |
| **開發環境** | Visual Studio Code | 推薦的程式碼編輯器，外掛豐富，對 Python 開發支援良好。 |
| **環境管理** | venv | Python 內建的虛擬環境工具，用於隔離專案所需的套件，保持系統環境乾淨。 |

**一鍵安裝所有 Python 套件：**

pip install NumPy Pillow PySide6 ModernGL

## **專案開發重點列項**

這是一個建議的開發路線圖，從核心演算法到完整的應用程式。

### **1\. 環境設定與專案結構**

* 使用 python \-m venv .venv 建立專案的虛擬環境。  
* 建立清晰的資料夾結構，例如：  
  * /app: 存放主要的 Python 程式碼。  
  * /shaders: 存放 GLSL 著色器檔案 (.vert, .frag)。  
  * /assets: 存放測試用的圖片。

### **2\. 演算法核心實作 (先用 CPU 版本驗證邏輯)**

在引入 GPU 加速前，先用 NumPy 在 CPU 上實現演算法，確保邏輯正確。這是最重要的一步。

* **A. 讀取影像**：使用 Pillow 載入圖片，並轉換為 NumPy 陣列。  
* **B. 建立低頻層 (Low Frequency)**：  
  * 這是影像的顏色和色調層。  
  * 實作方式：對原始影像的 NumPy 陣列執行**高斯模糊 (Gaussian Blur)**。可以使用 scipy.ndimage.gaussian\_filter 或 opencv-python 的 cv2.GaussianBlur 函式。  
* **C. 建立高頻層 (High Frequency)**：  
  * 這是影像的紋理和細節層。  
  * 實作方式：高頻層 \= 原始影像 \- 低頻層。  
  * **注意**：為避免數據溢位和負值問題，通常會將影像陣列的數據類型轉為浮點數（如 float32）再進行減法運算。為方便預覽，有時會加上 128 的灰階偏移 高頻層 \= 原始影像 \- 低頻層 \+ 128。  
* **D. 修飾圖層**：  
  * **修飾低頻層**：這是平滑皮膚、均勻膚色的關鍵。最簡單的自動化方法是**對低頻層再應用一次更細微的模糊**，這能有效地柔化色塊過渡。  
  * **修飾高頻層**：這是去除痘痘、疤痕等瑕疵的地方。在全自動化中較難，但在 UI 輔助下，可以讓使用者標記瑕疵區域，然後對該區域執行**內容感知填充 (Inpainting)** 演算法（如 cv2.inpaint）。  
* **E. 合併圖層**：  
  * 最終結果 \= 修飾後的低頻層 \+ 修飾後的高頻層 (如果高頻層有偏移，記得減回去)。  
  * 確保最終的像素值被裁剪回 0-255 的範圍內。

### **3\. 使用者介面 (UI) 開發**

* 使用 PySide6 建立主視窗。  
* 核心佈局：  
  * 中央是一個自訂的 QOpenGLWidget 用於顯示影像。  
  * 側邊欄包含一個 QSlider，其**關鍵作用是控制高斯模糊的半徑**，這是使用者最重要的互動工具。  
  * 包含 QPushButton 用於「載入」、「儲存」。

### **4\. GPU 加速整合**

這是專案從「能用」到「好用」的飛躍。

* 將步驟 2 中的 NumPy 運算邏輯用 GLSL 著色器重寫。  
* **高斯模糊 Shader**：在 GPU 上實現高斯模糊最高效的方式是**可分離濾波 (Separable Filter)**，即執行一次水平模糊，再對結果執行一次垂直模糊。這需要使用 **Framebuffer Object (FBO)** 來儲存中間結果。  
* **圖層混合 Shader**：編寫一個 Fragment Shader，它接收原始影像紋理和模糊後的低頻層紋理作為輸入，然後在 GPU 上直接執行加減法來產生最終的修飾效果。  
* **UI 聯動**：將 QSlider 的值改變事件，連接到更新 Shader 中 uniform 變數（模糊半徑）的函式，並觸發 QOpenGLWidget 的重繪。因為計算在 GPU 上是瞬時的，使用者將能體驗到**零延遲的即時預覽**。

### **5\. 檔案操作與工作流程**

* 實作「載入」按鈕功能，彈出檔案對話方塊，將選擇的圖片透過 Pillow \-\> NumPy \-\> ModernGL Texture 的流程載入到 GPU。  
* 實作「儲存」按鈕功能，將 GPU 中 FBO 的最終結果讀回到 CPU (fbo.read())，轉換為 NumPy 陣列，再透過 Pillow 儲存成檔案。